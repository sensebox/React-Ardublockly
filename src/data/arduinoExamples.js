import * as Blockly from "blockly/core";

export const ArduinoExamples = () => {
  return [
    {
      name: "MCU Component Test",
      description: "Test the different compoenents of the MCU",
      code: '// senseBox:home WiFi is enabled by default!\n// If you have a senseBox:home Ethernet comment out line 5\n// and comment in line 4\n// Do not comment in both at the same time!\n//#define ENABLE_ETHERNET\n#define ENABLE_WIFI\n\n#include <Wire.h>\n#include <SPI.h>\n#ifdef ENABLE_WIFI\n#include <WiFi101.h>\n#include <driver/source/nmasic.h>\n#endif\n#ifdef ENABLE_ETHERNET\n#include <Ethernet.h>\n#endif\n#include <Adafruit_Sensor.h>\n#include <Adafruit_BMP280.h>\n#include <Adafruit_BME280.h>\n#include <Adafruit_BME680.h>\n#include <Adafruit_HDC1000.h>\n#include <SDS011-select-serial.h>\n#include <senseBoxIO.h>\n/********WiFi User Settings********/\nconst char *ssid = ""; // your network SSID (name)\nconst char *pass = ""; // your network password\n/**********************************/\nchar server[] = "internet-test.testing.opensensemap.org";\n#ifdef ENABLE_WIFI\nint status = WL_IDLE_STATUS;\nWiFiClient client;\n#endif\n\n#ifdef ENABLE_ETHERNET\n/********Ethernet User Settings********/\n//Configure static IP setup (only needed if DHCP is disabled)\nbyte mac[] = {0xDE,0xAD,0xBE,0xEF,0xFE,0xED};\nIPAddress myIp(192, 168, 0, 42);\nIPAddress myDns(8, 8, 8, 8);\nIPAddress myGateway(192, 168, 0, 177);\nIPAddress mySubnet(255, 255, 255, 0);\n/**********************************/\nEthernetClient ethernetClient;\n#endif\n\n#define CMD_RESET (0x00)\n#define CMD_SEND  (0x03)\n#define ECC_READ  (0x02) // read command\n#define ECC_WRITE (0x12) // write command\n#define ECC_ZONE_CFG      (0x00)   // configuration zone\n#define ECC_ZONE_CNT_FLAG (0x80)   // 1=32 bytes, 0=4 bytes\nvoid setup() {\n  Serial.begin(9600);\n  while(!Serial); // wait until serial is ready\n  printMenu();\n  // power on required ports\n  senseBoxIO.powerI2C(false);\n  senseBoxIO.powerXB1(false);\n  senseBoxIO.powerUART(false);\n  delay(250);\n  senseBoxIO.powerI2C(true);\n  senseBoxIO.powerXB1(true);\n  senseBoxIO.powerUART(true);\n  // init UART and I2C\n  Serial1.begin(9600);\n  Serial2.begin(9600);\n  Wire.begin();\n}\nvoid loop() {\n    char rx;\n    if (Serial.available() > 0)\n    {\n\n      rx = Serial.read();       // get the character\n      Serial.println("\\n\\n");\n      // check if a number was received\n      switch(rx)\n      {\n        case \'1\':\n          check_uart_sensor();\n          Serial.println("\\nI2C/Wire:");\n          byte devices, address;\n          devices = 0;\n          for(address = 1; address < 127; address++ )\n          {\n            Wire.beginTransmission(address);\n            byte error = Wire.endTransmission();\n\n            if(error == 0)\n            {\n              devices++;\n              Serial.print("Device found at 0x");\n              delay(100);\n              Serial.print(address, HEX);\n              Serial.println();\n              check_i2c_sensor(address);\n            }\n            else if(error==4)\n            {\n              Serial.print("Unknow error at 0x");\n              delay(100);\n              Serial.println(address, HEX);\n            }\n          }\n\n          if(devices == 0) Serial.println("No devices found\\n");\n          senseBoxIO.statusNone();\n          delay(250);\n          break;\n        #ifdef ENABLE_WIFI\n        case \'2\':\n          connectionWiFiTest();\n          Serial.println("");\n          delay(250);\n          break;\n        #endif\n        #ifdef ENABLE_ETHERNET\n        case \'3\':\n          connectionEthernetTest();\n          Serial.println("");\n          delay(250);\n          break;\n        #endif\n        case \'4\':\n          Serial.println("Security key:");\n          getSecKey();\n          Serial.println();\n          delay(250);\n          break;\n        case \'5\':\n          Serial.flush();\n          NVIC_SystemReset();\n          break;\n      }\n      Serial.flush();\n   }\n}\nvoid printMenu()\n{\n  Serial.println("senseBox MCU option menu\\nType one of the numbers in the input field above and hit \'Enter\'.");\n  delay(100);\n  Serial.println(" 1 - Find connected devices");\n  #ifdef ENABLE_WIFI\n  delay(100);\n  Serial.println(" 2 - Test connection to openSenseMap (WiFi on XBee1)");\n  #endif\n  #ifdef ENABLE_ETHERNET\n  delay(100);\n  Serial.println(" 3 - Test connection to openSenseMap (Ethernet on XBee1)");\n  #endif\n  delay(100);\n  Serial.println(" 4 - Get security key\\n");\n  return;\n}\nvoid check_uart_sensor(){\n  Serial.println("UART/Serial Port:");\n  SDS011 sds1(Serial1);\n  SDS011 sds2(Serial2);\n  float pm10,pm25;\n  int sds_error;\n  sds_error = sds1.read(&pm25,&pm10);\n  if (!sds_error)\n  {\n    Serial.println("SDS011 dust particle sensor found at serial port #1.");\n  }\n  else\n  {\n    sds_error = sds2.read(&pm25,&pm10);\n    if (!sds_error)\n    {\n      Serial.println("SDS011 dust particle sensor found at serial port #2.");\n      return;\n    }\n  }\n  Serial.println("No device found.");\n}\nvoid check_i2c_sensor(byte address)\n{\n  float t=0, h=0, p=0, a=0;\n  unsigned int u=0;\n  unsigned long l=0;\n  Adafruit_BMP280 bmp280;\n  Adafruit_BME280 bme280;\n  Adafruit_BME680 bme680;\n  Adafruit_HDC1000 hdc;\n  if((address == 0) || (address > 127))\n  {\n    return;\n  }\n  switch(address)\n  {\n    case 0x29:  //TSL45315\n      Serial.println("--- TSL45315");\n      Wire.beginTransmission(address);\n      Wire.write(0x80|0x00); //control\n      Wire.write(0x03);\n      Wire.endTransmission();\n      Wire.beginTransmission(address);\n      Wire.write(0x80|0x01); //config\n      Wire.write(0x02); //M=4 T=100ms\n      Wire.endTransmission();\n      delay(120);\n      Wire.beginTransmission(address);\n      Wire.write(0x80|0x04); //data low\n      Wire.endTransmission();\n      Wire.requestFrom((uint8_t)address, (uint8_t)2);\n      delay(1);\n      u |= (Wire.read()<<8);\n      u |= (Wire.read()<<8);\n      l = u * 4;\n      Serial.print("Lux ");\n      Serial.println(l, DEC);\n      break;\n    case 0x38:  //VEML6070\n    //case 0x39:\n      Serial.println("--- VEML6070 (0x38+0x39)");\n      Wire.beginTransmission(address);\n      Wire.write((0x1<<2) | 0x02); //Integration Time 1\n      Wire.endTransmission();\n      delay(120);\n      Wire.requestFrom((uint8_t)(address+1), (uint8_t)1); //MSB\n      delay(1);\n      u |= (Wire.read()<<8);\n      Wire.requestFrom((uint8_t)(address+0), (uint8_t)1); //LSB\n      delay(1);\n      u |= (Wire.read()<<0);\n      Serial.print("UV ");\n      Serial.println(u, DEC);\n      break;\n    case 0x40:  //HDC100X\n    case 0x41:\n    //case 0x42:\n    case 0x43:\n      Serial.println("--- HDC100X");\n      hdc.begin(address);\n      t = hdc.readTemperature();\n      h = hdc.readHumidity();\n      Serial.print("Temp ");\n      Serial.print(t, DEC);\n      Serial.println(" *C");\n      Serial.print("Humi ");\n      Serial.print(h, DEC);\n      Serial.println(" %");\n      break;\n    case 0x76:  //BMP280 or BME280 or BME680\n    case 0x77:\n      if(bmp280.begin(address) != 0)\n      {\n        Serial.println("--- BMP280");\n        delay(100);\n        t = bmp280.readTemperature();\n        p = bmp280.readPressure();\n        a = bmp280.readAltitude(1013.25); //1013.25 = sea level pressure\n      }\n      else if(bme280.begin(address) != 0)\n      {\n        Serial.println("--- BME280");\n        delay(100);\n        t = bme280.readTemperature();\n        p = bme280.readPressure();\n        a = bme280.readAltitude(1013.25); //1013.25 = sea level pressure\n        h = bme280.readHumidity();\n      }\n      else if(bme680.begin(address) != 0)\n      {\n        Serial.println("--- BME680");\n        delay(100);\n        bme680.performReading();\n        t = bme680.temperature;\n        p = bme680.pressure;\n        a = bme680.readAltitude(1013.25); //1013.25 = sea level pressure\n        h = bme680.humidity;\n        u = bme680.gas_resistance / 1000.0;\n      }\n      else\n      {\n        Wire.beginTransmission(address);\n        Wire.write(0xD0); //chip id\n        Wire.endTransmission();\n        Wire.requestFrom(address, (byte)1);\n        delay(1);\n        u = Wire.read();\n             if(u == 0x58) //BMP280\n        {\n          Serial.println("--- BMP280");\n        }\n        else if(u == 0x60) //BME280\n        {\n          Serial.println("--- BME280");\n        }\n        else if(u == 0x61) //BME680\n        {\n          Serial.println("--- BME680");\n        }\n      }\n      Serial.print("Temp ");\n      Serial.print(t, DEC);\n      Serial.println(" *C");\n      Serial.print("Pres ");\n      Serial.print(p/100.0, DEC);\n      Serial.println(" hPa");\n      Serial.print("Alti ");\n      Serial.print(a, DEC);\n      Serial.println(" m");\n      if(h != 0)\n      {\n        Serial.print("Humi ");\n        Serial.print(h, DEC);\n        Serial.println(" %");\n      }\n      if(u != 0)\n      {\n        Serial.print("Gas  ");\n        Serial.print(u, DEC);\n        Serial.println(" kOhm");\n      }\n      break;\n    case 0x42:  //CAM-M8Q\n      Serial.println("--- CAM-M8Q");\n      break;\n    case 0x50:  //24LCxxx EEPROM\n      Serial.println("--- 24LCxxx");\n      break;\n    case 0x60:  //ATECCx08\n      Serial.println("--- ATECCx08");\n      break;\n    case 0x68:  //RV8523\n      Serial.println("--- RV8523");\n      break;\n  }\n  delay(250); //wait 250ms\n}\nvoid getSecKey()\n{\n  Wire1.begin();\n  // init ATECC\n  write(CMD_RESET, 0x00); // reset\n  delay(100); // wait 100ms\n  // read config zone\n  byte buf[64]; // buffer\n  buf[0] = 5+2; // length: data + 2 crc bytes\n  buf[1] = ECC_READ; // cmd\n  buf[2] = ECC_ZONE_CFG|ECC_ZONE_CNT_FLAG; // param 1\n  buf[3] = 0x00; // addr lsb\n  buf[4] = 0x00; // addr msb\n  //buf[5] = 0x00; // crc\n  //buf[6] = 0x00; // crc\n  calc_crc(buf, buf[0]-2, &buf[5]); // calc crc\n  write(CMD_SEND, buf, buf[0]); // send cmd\n  delay(10); // wait 10ms\n  read(buf, sizeof(buf)); // read response\n  Serial.print("0");\n  Serial.print(buf[1], HEX); Serial.print(" ");\n  Serial.print(buf[2], HEX); Serial.print(" ");\n  Serial.print(buf[3], HEX); Serial.print(" ");\n  Serial.print(buf[4], HEX); Serial.print(" ");\n  Serial.print(buf[ 9], HEX); Serial.print(" ");\n  Serial.print(buf[10], HEX); Serial.print(" ");\n  Serial.print(buf[11], HEX); Serial.print(" ");\n  Serial.print(buf[12], HEX); Serial.print(" ");\n  Serial.print(buf[13], HEX); Serial.print(" ");\n  Serial.println("");\n}\nvoid read(byte *data, byte max_len)\n{\n  byte len;\n  Wire1.requestFrom(I2C_ATECC, 1);      // request length\n  while(Wire1.available() == 0);        // wait for data bytes\n  len = Wire1.read();\n  *data++ = len;\n  if(len)\n  {\n    Wire1.requestFrom(I2C_ATECC, len);  // request x bytes\n    while(Wire1.available() == 0);      // wait for data bytes\n    delay(10); // wait 10ms\n    for(byte i = 0; (i < len) && (i < max_len); i++)\n    {\n      *data++ = Wire1.read();           // read data byte\n    }\n  }\n}\nvoid write(byte reg, byte *data, byte len)\n{\n  Wire1.beginTransmission(I2C_ATECC); // start transmission\n  Wire1.write(reg);                   // write register byte\n  for(; len != 0; len--)\n  {\n    Wire1.write(*data++);             // write data byte\n  }\n  Wire1.endTransmission();            // stop transmission\n}\nvoid write(byte reg, byte data)\n{\n  Wire1.beginTransmission(I2C_ATECC); // start transmission\n  Wire1.write(reg);                   // write register byte\n  Wire1.write(data);                  // write data byte\n  Wire1.endTransmission();            // stop transmission\n}\nvoid calc_crc(byte *data, byte len, byte *crc)\n{\n  uint8_t i, shift_reg, data_bit, crc_bit;\n  uint16_t crc_reg = 0;\n  uint16_t polynom = 0x8005;\n  for(i = 0; i < len; i++)\n  {\n    for(shift_reg = 0x01; shift_reg > 0x00; shift_reg <<= 1)\n    {\n      data_bit = (data[i] & shift_reg) ? 1 : 0;\n      crc_bit = crc_reg >> 15;\n      crc_reg <<= 1;\n      if(data_bit != crc_bit)\n      {\n        crc_reg ^= polynom;\n      }\n    }\n  }\n  crc[0] = (byte)(crc_reg & 0x00FF);\n  crc[1] = (byte)(crc_reg >> 8);\n}\nvoid connectionWiFiTest(){\n  #ifdef ENABLE_WIFI\n  if (WiFi.status() == WL_NO_SHIELD)\n  {\n    Serial.println("WiFi bee not present");\n    return;\n  }\n  Serial.println("Check WiFi firmware:");\n  Serial.println("====================");\n  // Print firmware version on the shield\n  String fv = WiFi.firmwareVersion();\n  String latestFv;\n  Serial.print("Firmware version installed: ");\n  Serial.println(fv);\n\n  if (REV(GET_CHIPID()) >= REV_3A0) {\n    // model B\n    latestFv = WIFI_FIRMWARE_LATEST_MODEL_B;\n  } else {\n    // model A\n    latestFv = WIFI_FIRMWARE_LATEST_MODEL_A;\n  }\n\n  // Print required firmware version\n  Serial.print("Latest firmware version available : ");\n  Serial.println(latestFv);\n\n  // Check if the latest version is installed\n  Serial.println();\n  if (fv == latestFv || fv == "19.5.2") {\n    Serial.println("Check result: PASSED");\n  } else {\n    Serial.println("Check result: NOT PASSED");\n    Serial.println(" - The firmware version on the shield do not match the");\n    Serial.println("   version required by the library, you may experience");\n    Serial.println("   issues or failures.");\n    Serial.println(" - Update the firmware at least to version 19.5.2");\n  }\n\n  Serial.println();\n  Serial.println("Check internet connectivity:");\n  Serial.println("============================");\n\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.print("Connecting to WiFi...");\n    delay(1000); // wait 1s\n    WiFi.begin(ssid, pass);\n    delay(5000); // wait 5s\n  }\n  if (WiFi.status() == WL_CONNECTED) Serial.println("connected!");\n  else\n  {\n    Serial.println("failed! Please check SSID and password.");\n    return;\n  }\n  for (uint8_t timeout = 2; timeout != 0; timeout--)\n  {\n    Serial.print("Calling openSenseMap server...");\n    if (client.connect(server, 80))\n    {\n      Serial.println("connected!");\n      // Make a HTTP request:\n      client.println("GET / HTTP/1.1");\n      client.print("Host: ");\n      client.println(server);\n      client.println("Connection: close");\n      client.println();\n    }\n    break;\n  }\n  if(client.connected())\n  {\n    // wait for server response\n    Serial.println("Server response:\\n");\n    while (!client.available())\n    {\n      delay(1);\n    }\n    // read server response\n    while (client.available())\n    {\n      char c = client.read();\n      Serial.write(c);\n    }\n    Serial.print("\\n");\n    Serial.println("Disconnecting from server.");\n    client.flush();\n    client.stop();\n  }else Serial.println("failed after 3 trys!");\n  Serial.println("Disconnecting from WiFi.");\n  WiFi.disconnect();\n  #endif\n}\n\nvoid connectionEthernetTest() {\n  #ifdef ENABLE_ETHERNET\n  Ethernet.init(PIN_XB1_CS);\n  Serial.println("Trying to initialize DHCP...");\n  if (Ethernet.begin(mac) == 0) {\n    Serial.println("Failed to configure Ethernet using DHCP");\n    // start the Ethernet connection using a fixed IP address and DNS server:\n    Serial.println("Trying Ethernet connection using a fixed IP address and DNS server");\n    Ethernet.begin(mac, myIp, myDns, mySubnet);\n  } else {\n    // print your local IP address:\n    Serial.println("DHCP is working.");\n    Serial.print("My IP address: ");\n    for (byte thisByte = 0; thisByte < 4; thisByte++) {\n      // print the value of each byte of the IP address:\n      Serial.print(Ethernet.localIP()[thisByte], DEC);\n      Serial.print(".");\n    }\n    Serial.println();\n  }\n  for (uint8_t timeout = 2; timeout != 0; timeout--)\n  {\n    Serial.print("Calling openSenseMap server...");\n    if (ethernetClient.connect(server, 80))\n    {\n      Serial.println("connected!");\n      // Make a HTTP request:\n      ethernetClient.println("GET / HTTP/1.1");\n      ethernetClient.print("Host: ");\n      ethernetClient.println(server);\n      ethernetClient.println("Connection: close");\n      ethernetClient.println();\n    }\n    break;\n  }\n  if(ethernetClient.connected())\n  {\n    // wait for server response\n    Serial.println("Server response:\\n");\n    while (!ethernetClient.available())\n    {\n      delay(1);\n    }\n    // read server response\n    while (ethernetClient.available())\n    {\n      char c = ethernetClient.read();\n      Serial.write(c);\n    }\n    Serial.print("\\n");\n    Serial.println("Disconnecting from server.");\n    ethernetClient.flush();\n    ethernetClient.stop();\n  }\n  else Serial.println("failed after 3 trys!");\n  #endif\n}',
    },
    {
      name: "ArduinoBearSSL",
      description: "BearSSL is a TLS/SSL library for Arduino",
      code: "",
    },
  ];
};
